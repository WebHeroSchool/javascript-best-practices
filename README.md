Javadcript Best Practices
---
Здесь приведены советы при написании хорошего, красивого javascript кода



### 1). Всегда объявлять локальные переменные.

Все переменные , используемые в функции должны быть объявлены как локальные переменные, то есть объявлены с ключевым словом var, let или const.
В противном случае они станут глобальными переменными.

Переменные, значение которых может измениться, следует объявлять черех `let`, так как он более локален в блоках и имеет понятное поведение.
Для переменнх, значение которых не изменяется, например, элементы верстки, следует применять объявление через `const`.
Объявление переменных через `var` следует применять в крайних случаях, так как область видимости такой переменной будет слишком большой.

``` js
//global
value;

//local
var block = [];
let element = "";
const button = idElem;
```

Строгий режим не позволяет необъявленных переменных.



### 2). Объявления переменных в начале

Переменные объявляются в начале кода или функции.

Это дает возможность единого места поиска переменных, снижает возможность повторного объявления переменной и
делает код чище.

``` js
var firstName = "",
    lastName = "",
    price = 0,
    discount = 0,
    fullPrice = 0,
    myArray = [],
    myObject = {};

function sayHi ( name ) {
  alert( name + ", hi!" );
}
```



### 3). Инициализировать переменные.

В примере выше все переменные инициализированы при объявлении, это позволяет сразу определить тип используемых данных и избежать получения нежелательных неопределенных значений.



### 4). Объявлять число, строку или булево значение, как примитив.

Всегда рассматривать числа, строки или булевые значения как примитивные, не в качестве объекта.
Это позволяет увеличить скорость выполнения и не вызовет неприятных побочных явлений.

``` js
var x = "John";             
var y = new String( "John" );
(x === y) // false, так как х - string, y - object.
```



### 5). Не применять инициализацию через new.

+ Используйте {} вместо new Object()
+ Используйте "" вместо new String()
+ Используйте 0 вместо new Number()
+ Используйте false вместо new Boolean()
+ Используйте [] вместо new Array()
+ Используйте /()/ вместо new RegExp()
+ Используйте function() {} вместо new Function()

``` js
var x1 = {};           // new object
var x2 = "";           // new primitive string
var x3 = 0;            // new primitive number
var x4 = false;        // new primitive boolean
var x5 = [];           // new array object
var x6 = /()/;         // new regexp object
var x7 = function(){}; // new function object
```



### 6). Применять строгое сравнение === вместо ==

  - ==Оператор сравнения всегда преобразует (к соответствию типов) перед сравнением.
  - ===Оператор силы Сравнение значений и типов:

``` js
0 == "";        // true
1 == "1";       // true
1 == true;      // true

0 === "";       // false
1 === "1";      // false
1 === true;     // false
```


### 7). Присвоение значения по умолчанию.

Хорошая практика присваивать значения по умолчанию, так как неопределенные значения undefined могут привести к поломке кода.

Например, если функция вызывается без аргумента:

``` js
function myFunction(x, y) {
  if (y === undefined) {
    y = 0; // при дальнейшем использовании у, его значение будет определенным 
  }
}
```


### 8). Устанавливать default значение в конструкции Switch.

``` js
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
    break;
  default:
    day = "Unknown";
}
```


### 9). Замена немедленно вызываемых функций (IIFE) на блоки (Blocks)

Обычно немедленно вызываемые функции используют для ограждения значений в их областях видимости. В ES6 можно создавать блочные области видимости.

``` js
(function () {
    var food = 'Meow Mix';
}());

console.log(food); // Reference Error
```
Пример Blocks
``` js
{
    let food = 'Meow Mix';
};

console.log(food); // Reference Error
```

Такая конструкция имеет более приятный вид, а главное выполняет поставленную задачу, скрыть значение переменной `food`.



### 10). Шаблонные литералы (ES6)

Шаблонные литералы поддерживают интерполяцию, что делает задачу конкатенации строк и значений:

```js
var name = 'Tiger';
var age = 13;

console.log('My cat is named ' + name + ' and is ' + age + ' years old.');
```
Гораздо проще:
``` js
const name = 'Tiger';
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
```

Помимо всего, шаблонные литералы сохраняют перенос строк:
``` js
let text = ( `cat
dog
nickelodeon`
);
```


Этот список будет пополняться и расширяться.

(https://tproger.ru/translations/es6-cheatsheet-1/)
(https://www.w3schools.com/js/js_best_practices.asp)



